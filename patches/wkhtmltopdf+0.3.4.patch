diff --git a/node_modules/wkhtmltopdf/index.js b/node_modules/wkhtmltopdf/index.js
index d2e985d..3f90581 100644
--- a/node_modules/wkhtmltopdf/index.js
+++ b/node_modules/wkhtmltopdf/index.js
@@ -1,6 +1,8 @@
+//PATCHED FOR CREATING WINSTON LOGS
 var spawn = require('child_process').spawn;
 var slang = require('slang');
 var isStream = require('is-stream');
+const { loggerWk } = require(`${__dirname}/../../src/utils/logger`);
 
 function quote(val) {
   // escape and quote the value if it is a string and this isn't windows
@@ -11,7 +13,7 @@ function quote(val) {
   return val;
 }
 
-function wkhtmltopdf(input, options, callback) {
+function wkhtmltopdf(input, options, reqDate, callback) {
   if (!options) {
     options = {};
   } else if (typeof options == 'function') {
@@ -24,27 +26,40 @@ function wkhtmltopdf(input, options, callback) {
 
   // make sure the special keys are last
   var extraKeys = [];
-  var keys = Object.keys(options).filter(function(key) {
-    if (key === 'toc' || key === 'cover' || key === 'page') {
-      extraKeys.push(key);
-      return false;
-    }
+  var keys = Object.keys(options)
+    .filter(function (key) {
+      if (key === 'toc' || key === 'cover' || key === 'page') {
+        extraKeys.push(key);
+        return false;
+      }
 
-    return true;
-  }).concat(extraKeys);
+      return true;
+    })
+    .concat(extraKeys);
 
   // make sure toc specific args appear after toc arg
   if (keys.indexOf('toc') >= 0) {
-    var tocArgs = ['disableDottedLines', 'tocHeaderText', 'tocLevelIndentation', 'disableTocLinks', 'tocTextSizeShrink', 'xslStyleSheet'];
+    var tocArgs = [
+      'disableDottedLines',
+      'tocHeaderText',
+      'tocLevelIndentation',
+      'disableTocLinks',
+      'tocTextSizeShrink',
+      'xslStyleSheet',
+    ];
     var myTocArgs = [];
-    keys = keys.filter(function(key){
-      if (tocArgs.find(function(tkey){ return tkey === key })) {
+    keys = keys.filter(function (key) {
+      if (
+        tocArgs.find(function (tkey) {
+          return tkey === key;
+        })
+      ) {
         myTocArgs.push(key);
         return false;
       }
       return true;
     });
-    var spliceArgs = [keys.indexOf('toc')+1, 0].concat(myTocArgs);
+    var spliceArgs = [keys.indexOf('toc') + 1, 0].concat(myTocArgs);
     Array.prototype.splice.apply(keys, spliceArgs);
   }
 
@@ -53,9 +68,10 @@ function wkhtmltopdf(input, options, callback) {
     args.push('--quiet');
   }
 
-  keys.forEach(function(key) {
+  keys.forEach(function (key) {
     var val = options[key];
-    if (key === 'ignore' || key === 'debug' || key === 'debugStdOut') { // skip adding the ignore/debug keys
+    if (key === 'ignore' || key === 'debug' || key === 'debugStdOut') {
+      // skip adding the ignore/debug keys
       return false;
     }
 
@@ -63,18 +79,21 @@ function wkhtmltopdf(input, options, callback) {
       key = key.length === 1 ? '-' + key : '--' + slang.dasherize(key);
     }
 
-    if (Array.isArray(val)) { // add repeatable args
-      val.forEach(function(valueStr) {
+    if (Array.isArray(val)) {
+      // add repeatable args
+      val.forEach(function (valueStr) {
         args.push(key);
-        if (Array.isArray(valueStr)) { // if repeatable args has key/value pair
-          valueStr.forEach(function(keyOrValueStr) {
+        if (Array.isArray(valueStr)) {
+          // if repeatable args has key/value pair
+          valueStr.forEach(function (keyOrValueStr) {
             args.push(quote(keyOrValueStr));
           });
         } else {
           args.push(quote(valueStr));
         }
       });
-    } else { // add normal args
+    } else {
+      // add normal args
       if (val !== false) {
         args.push(key);
       }
@@ -86,29 +105,37 @@ function wkhtmltopdf(input, options, callback) {
   });
 
   var isUrl = /^(https?|file):\/\//.test(input);
-  args.push(isUrl ? quote(input) : '-');    // stdin if HTML given directly
-  args.push(output ? quote(output) : '-');  // stdout if no output file
+  args.push(isUrl ? quote(input) : '-'); // stdin if HTML given directly
+  args.push(output ? quote(output) : '-'); // stdout if no output file
 
   // show the command that is being run if debug opion is passed
   if (options.debug && !(options instanceof Function)) {
-    console.log('[node-wkhtmltopdf] [debug] [command] ' + args.join(' '));
+    loggerWk.info(
+      reqDate + '[node-wkhtmltopdf] [debug] [command] ' + args.join(' '),
+    );
   }
 
   if (process.platform === 'win32') {
     var child = spawn(args[0], args.slice(1));
   } else if (process.platform === 'darwin') {
-    var child = spawn('/bin/sh', ['-c', args.join(' ') + ' | cat ; exit ${PIPESTATUS[0]}']);
+    var child = spawn('/bin/sh', [
+      '-c',
+      args.join(' ') + ' | cat ; exit ${PIPESTATUS[0]}',
+    ]);
   } else {
     // this nasty business prevents piping problems on linux
     // The return code should be that of wkhtmltopdf and not of cat
     // http://stackoverflow.com/a/18295541/1705056
-    var child = spawn(wkhtmltopdf.shell, ['-c', args.join(' ') + ' | cat ; exit ${PIPESTATUS[0]}']);
+    var child = spawn(wkhtmltopdf.shell, [
+      '-c',
+      args.join(' ') + ' | cat ; exit ${PIPESTATUS[0]}',
+    ]);
   }
 
   var stream = child.stdout;
 
   // call the callback with null error when the process exits successfully
-  child.on('exit', function(code) {
+  child.on('exit', function (code) {
     if (code !== 0) {
       stderrMessages.push('wkhtmltopdf exited with code ' + code);
       handleError(stderrMessages);
@@ -125,8 +152,8 @@ function wkhtmltopdf(input, options, callback) {
       // check ignore warnings array before killing child
       if (options.ignore && options.ignore instanceof Array) {
         var ignoreError = false;
-        options.ignore.forEach(function(opt) {
-          err.forEach(function(error) {
+        options.ignore.forEach(function (opt) {
+          err.forEach(function (error) {
             if (typeof opt === 'string' && opt === error) {
               ignoreError = true;
             }
@@ -141,7 +168,7 @@ function wkhtmltopdf(input, options, callback) {
       }
       errObj = new Error(err.join('\n'));
     } else if (err) {
-      errObj =  new Error(err);
+      errObj = new Error(err);
     }
     child.removeAllListeners('exit');
     child.kill();
@@ -157,29 +184,37 @@ function wkhtmltopdf(input, options, callback) {
     }
   }
 
-  child.once('error', function(err) {
+  child.once('error', function (err) {
     throw new Error(err); // critical error
   });
 
-  child.stderr.on('data', function(data) {
+  child.stderr.on('data', function (data) {
     stderrMessages.push((data || '').toString());
     if (options.debug instanceof Function) {
       options.debug(data);
     } else if (options.debug) {
-      console.log('[node-wkhtmltopdf] [debug] ' + data.toString());
+      const logLevel = data.toString().startsWith('Warn') ? 'warn' : 'error';
+      loggerWk[logLevel](
+        reqDate + '[node-wkhtmltopdf] [debug] ' + data.toString(),
+      );
     }
   });
 
   if (options.debugStdOut && !output) {
-    throw new Error('debugStdOut may not be used when wkhtmltopdf\'s output is stdout');
+    throw new Error(
+      "debugStdOut may not be used when wkhtmltopdf's output is stdout",
+    );
   }
 
   if (options.debugStdOut && output) {
-    child.stdout.on('data', function(data) {
+    child.stdout.on('data', function (data) {
       if (options.debug instanceof Function) {
         options.debug(data);
       } else if (options.debug) {
-        console.log('[node-wkhtmltopdf] [debugStdOut] ' + data.toString());
+        const logLevel = data.toString().startsWith('Warn') ? 'warn' : 'error';
+        loggerWk[loglevel](
+          reqDate + '[node-wkhtmltopdf] [debugStdOut] ' + data.toString(),
+        );
       }
     });
   }
